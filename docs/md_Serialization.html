<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Dim: Input and Output</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Dim<span id="projectnumber">&#160;2.0.1</span>
   </div>
   <div id="projectbrief">Compile time dimensional analysis</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_Serialization.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Input and Output</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md22"></a> In Dim, "input and output" is used to mean deserialization and serialization from text.</p>
<h1><a class="anchor" id="autotoc_md23"></a>
High-level I/O</h1>
<p>Serialization and deserialization can be performed with stream operators, <code>to_string()</code>/<code>from_string()</code>, and <code>std::format()</code>. For example </p><div class="fragment"><div class="line">si::Mass stuff = 2.0 * si::pound_mass;</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;The stuff masses &quot;</span> &lt;&lt; stuff &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>; <span class="comment">// &quot;The stuff masses 4.41_kg&quot;</span></div>
<div class="line">std::string input = <span class="stringliteral">&quot;3.5_kg&quot;</span>;</div>
<div class="line">std::from_string(stuff, input);</div>
<div class="line">std::cout &lt;&lt; std::format(<span class="stringliteral">&quot;The new mass is {:1}\n&quot;</span>, stuff); <span class="comment">// &quot;The new mass is 4.4_kg&quot;</span></div>
</div><!-- fragment --><p> Dim uses a custom locale facet to store formatting information for these functions. You can install and adjust the locale like this: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;dim/si.hpp&gt;</span></div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacedim_1_1si.html">si</a> = ::dim::si;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Let&#39;s format angles as degrees</span></div>
<div class="line">    <span class="keyword">auto</span>* facet = si::system::make_default_facet(); <span class="comment">// obtain the default si facet    </span></div>
<div class="line">    <a class="code hl_class" href="classdim_1_1formatter.html">si::formatter&lt;si::Angle&gt;</a> degree_formatter(<span class="stringliteral">&quot;deg&quot;</span>, si::degree);</div>
<div class="line">    facet-&gt;output_formatter(degree_formatter); <span class="comment">// Set a new output format for angles    </span></div>
<div class="line">    si::add_to_global_locale(facet); <span class="comment">// Install the updated facet in the global locale</span></div>
<div class="line">    </div>
<div class="line">    si::Angle angle = M_PI*0.5 * si::radian;    </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Angle is &quot;</span> &lt;&lt; angle &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>; <span class="comment">// &quot;Angle is 90_deg&quot;</span></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassdim_1_1formatter_html"><div class="ttname"><a href="classdim_1_1formatter.html">dim::formatter</a></div><div class="ttdoc">Instructions on how to format type Q.</div><div class="ttdef"><b>Definition</b> io.hpp:88</div></div>
<div class="ttc" id="anamespacedim_1_1si_html"><div class="ttname"><a href="namespacedim_1_1si.html">dim::si</a></div><div class="ttdoc">Namespace for the International System (SI) of units.</div><div class="ttdef"><b>Definition</b> si.hpp:18</div></div>
</div><!-- fragment --><p> Formatters are discussed below.</p>
<h1><a class="anchor" id="autotoc_md24"></a>
Formatters</h1>
<p>Input/output in Dim rests on the <code>formatter</code> class. The formatter is a simple class that associates a string "symbol" with information on how to nondimensionalize a quantity. For example </p><div class="fragment"><div class="line"><a class="code hl_class" href="classdim_1_1formatter.html">si::formatter</a> degree_formatter(<span class="stringliteral">&quot;deg&quot;</span>, si::degree);</div>
</div><!-- fragment --><p> will format angles as degrees. The first argument is the symbol string ("deg"), and the second argument gives what you would multiply 1.0 by to obtain a quantity of the indicated symbol (<code>si::degree</code>). There's an optional third argument that is used for temperature conversion as an additive offset: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classdim_1_1formatter.html">si::formatter</a> fahrenheit_format(<span class="stringliteral">&quot;F&quot;</span>, 5./9.*kelvin, 255.37*kelvin);</div>
</div><!-- fragment --><p>Formatters provide <code>input</code> and <code>output</code> methods. Input takes the form </p><div class="fragment"><div class="line">si::Angle x = degree_formatter.input&lt;si::Angle&gt;(90.0);</div>
</div><!-- fragment --><p> while output is </p><div class="fragment"><div class="line">si::formatted_quantity&lt;double&gt; fmt = degree_formatter.output(2_rad);</div>
</div><!-- fragment --><p> The <code>formatted_quantity</code> divides the output into a scalar (double) part <code>value()</code> and a <code>char const*</code> symbol part <code>symbol()</code>. This allows you to do </p><div class="fragment"><div class="line">printf(<span class="stringliteral">&quot;My angle is %g_%s\n&quot;</span>, fmt.value(), fmt.symbol());</div>
</div><!-- fragment --><p> or put the result into structured XML, etc. An overload for <code>operator&lt;&lt;</code> and <code>std::formatter</code> allows for interaction with <code>ostream</code> and <code>std::format</code>. For example: </p><div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;My angle is &quot;</span> &lt;&lt; degree_formatter.output(2_rad) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md25"></a>
Format Maps</h2>
<p>The facet maintains a map from input type to symbol for each quantity type indexed by the symbol string. If the input unit string is an exact match to a map entry, that formatter is used to parse the quantity. This provides a flexible system where you can provide formatters for whatever domain-specific conventions you work with. Dim ships with format maps for many common quantities. These are derived from the NIST suggestions. For instance, here's the default length map: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> format_map&lt;Length&gt; s_known {</div>
<div class="line">    {<span class="stringliteral">&quot;in&quot;</span>,   formatter&lt;Length&gt;(<span class="stringliteral">&quot;in&quot;</span>, inch) },</div>
<div class="line">    {<span class="stringliteral">&quot;inch&quot;</span>, formatter&lt;Length&gt;(<span class="stringliteral">&quot;inch&quot;</span>, inch)},</div>
<div class="line">    {<span class="stringliteral">&quot;ft&quot;</span>,   formatter&lt;Length&gt;(<span class="stringliteral">&quot;ft&quot;</span>, foot)},</div>
<div class="line">    {<span class="stringliteral">&quot;foot&quot;</span>, formatter&lt;Length&gt;(<span class="stringliteral">&quot;foot&quot;</span>, foot)},</div>
<div class="line">    {<span class="stringliteral">&quot;yd&quot;</span>,   formatter&lt;Length&gt;(<span class="stringliteral">&quot;yd&quot;</span>, yard)},</div>
<div class="line">    {<span class="stringliteral">&quot;yard&quot;</span>, formatter&lt;Length&gt;(<span class="stringliteral">&quot;yard&quot;</span>, yard)},</div>
<div class="line">    {<span class="stringliteral">&quot;mi&quot;</span>,   formatter&lt;Length&gt;(<span class="stringliteral">&quot;mi&quot;</span>, mile)},</div>
<div class="line">    {<span class="stringliteral">&quot;mile&quot;</span>, formatter&lt;Length&gt;(<span class="stringliteral">&quot;mile&quot;</span>, mile)},</div>
<div class="line">    {<span class="stringliteral">&quot;nmi&quot;</span>,  formatter&lt;Length&gt;(<span class="stringliteral">&quot;nmi&quot;</span>, nautical_mile)},</div>
<div class="line">    {<span class="stringliteral">&quot;nautical_mile&quot;</span>, formatter&lt;Length&gt;(<span class="stringliteral">&quot;nautical_mile&quot;</span>, nautical_mile)}</div>
<div class="line">};</div>
</div><!-- fragment --><p> Note that "m" and related SI ("km", "mm", etc) units aren't included because they are handled by the fallback parser below &ndash; SI units are generally easy to parse. But suppose for your domain, you wanted to accept "feet" for "foot" and "nm" for nautical mile (yes, that's a symbol clash with nanometer &ndash; but you know what your users expect). You could add these to the facet via </p><div class="fragment"><div class="line"><span class="keyword">auto</span>* facet = <a class="code hl_function" href="namespacedim_1_1si.html#ae52eeeca6076ffd217997a0b275f1a95">si::make_default_facet</a>(); <span class="comment">// obtain the default si facet    </span></div>
<div class="line">facet-&gt;input_formatter(formatter&lt;Length&gt;(<span class="stringliteral">&quot;feet&quot;</span>, foot));</div>
<div class="line">facet-&gt;input_formatter(formatter&lt;Length&gt;(<span class="stringliteral">&quot;nm&quot;</span>, nautical_mile));</div>
<div class="line"><a class="code hl_function" href="namespacedim_1_1si.html#a21fec3766288749907f7d7a42c25682a">si::install_facet</a>(facet);</div>
<div class="ttc" id="anamespacedim_1_1si_html_a21fec3766288749907f7d7a42c25682a"><div class="ttname"><a href="namespacedim_1_1si.html#a21fec3766288749907f7d7a42c25682a">dim::si::install_facet</a></div><div class="ttdeci">void install_facet(si::facet *i_quantity_facet)</div><div class="ttdoc">Install the default quantity facet into the global locale. Imbue cout, cerr, and clog with it.</div><div class="ttdef"><b>Definition</b> si_facet.cpp:25</div></div>
<div class="ttc" id="anamespacedim_1_1si_html_ae52eeeca6076ffd217997a0b275f1a95"><div class="ttname"><a href="namespacedim_1_1si.html#ae52eeeca6076ffd217997a0b275f1a95">dim::si::make_default_facet</a></div><div class="ttdeci">facet * make_default_facet()</div><div class="ttdoc">Obtain the default quantity_facet for si. You must either pass this pointer to the locale or delete i...</div><div class="ttdef"><b>Definition</b> si_facet.cpp:41</div></div>
</div><!-- fragment --><p> or you can use your map directly as shown below. Because the map is consulted before the fallback parser is called, you've overridden the meaning of "nm" for your program.</p>
<h1><a class="anchor" id="autotoc_md26"></a>
Low Level I/O</h1>
<p>Dim provides the functions </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Q, DIM_IS_QUANTITY(Q)&gt;</div>
<div class="line"><span class="keywordtype">bool</span> format_quantity(formatted_quantity&lt;typename Q::scalar&gt;&amp; o_formatted, Q <span class="keyword">const</span>&amp; i_q,</div>
<div class="line">                     output_format_map&lt;typename Q::scalar, typename Q::system&gt; <span class="keyword">const</span>* i_out_map = <span class="keyword">nullptr</span>)</div>
<div class="line"> </div>
<div class="line">template &lt;class Q, DIM_IS_QUANTITY(Q)&gt;</div>
<div class="line"><span class="keywordtype">bool</span> parse_quantity(Q&amp; o_q, formatted_quantity&lt;typename Q::scalar&gt; const&amp; i_formatted,</div>
<div class="line">                    input_format_map&lt;typename Q::scalar, typename Q::system&gt; const&amp; i_unit_map = get_default_format&lt;Q&gt;())</div>
</div><!-- fragment --><p> and related <code>dynamic_quantity</code> versions for fully-customizable formatting. The default <code>i_out_map</code> argument disables the use of the output symbol map, while the <code>i_unit_map</code> default argument obtains the default symbol map for <code>Q</code> provided by Dim. These functions transform quantities into formatted quantitys and vice-versa using collections of formatters called format maps. In fact, the IO facet is really just a convenient storage place for these maps.</p>
<h1><a class="anchor" id="autotoc_md27"></a>
Fallback IO</h1>
<p>What happens if the facet doesn't exist in the locale, or if the facet doesn't have a formatter for our case? Dim provides fallback options in these cases described below.</p>
<h2><a class="anchor" id="autotoc_md28"></a>
Basic Format</h2>
<p>A symbol is associated with each dimension in a system, so a unit symbol can be reconstructed. This is correct, but it isn't usually very pretty. Thus suppose we had a torque we wanted to print: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classdim_1_1quantity.html">si::Torque</a> T = 3_N * 2_m / 1.2_rad;</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Torque is &quot;</span> &lt;&lt; T &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="ttc" id="aclassdim_1_1quantity_html"><div class="ttname"><a href="classdim_1_1quantity.html">dim::quantity</a></div><div class="ttdoc">Combination of a scalar and a unit. Most dim types are typedefs for template instatiations of this.</div><div class="ttdef"><b>Definition</b> quantity.hpp:46</div></div>
</div><!-- fragment --><p> If there's no output formatter for <code>si::Torque</code>, the output will be "5_rad^-1_kg_m^2_s^-2".</p>
<h2><a class="anchor" id="autotoc_md29"></a>
Parsing Quantities</h2>
<p>Input is a different beast. Because Dim is strongly typed, we know the desired quantity type. The task is to verify that the input string can be parsed to a matching dimension, then apply the conversion factor for that dimension to the scalar part.</p>
<p>When no input formatter matches a symbol, Dim falls back to a parser for SI types. This parser recognizes all of the SI prefixes and (almost all*) symbols defined in NIST SP 811. It recognizes <code>_</code>, <code>*</code> as multiplication, <code>/</code> as division, and <code>^</code> as exponentiation. Units and exponents may be grouped with parentheses. The parser is case-sensitive (this is required by the SI notation). Examples of parsed strings include</p><ul>
<li>μm_s^-2</li>
<li>(MPa)^2/mol^(3)</li>
</ul>
<p>*Dim does not support the symbol "a" for the are unit of area (as in "hectare"). This symbol leads to ambiguities. Forms of the are other than the hectare appear to be rare.</p>
<h1><a class="anchor" id="autotoc_md30"></a>
Design of Serialization/Deserialization</h1>
<h2><a class="anchor" id="autotoc_md31"></a>
Serialized Quantities</h2>
<p>A serialized quantity is a string of the form </p><div class="fragment"><div class="line">&lt;serialized scalar&gt;[separator]&lt;serialized unit&gt;</div>
</div><!-- fragment --><p> Routines in Dim transform quantities and dynamic_quantities into <code>formatted_quantity</code> types. These can then be streamed, turned into strings, or used with <code>std::format</code>. Likewise, deserialization turns input streams (istreams, strings, <code>char const*</code>, ...) back into <code>formatted_quantity</code> types. Parsers then work on the <code>&lt;serialized unit&gt;</code> string to complete the conversion back to <code>quantity</code>/<code>dynamic_quantity</code>.</p>
<p><code>&lt;serialized scalar&gt;</code> is a string representing the "number part" of a quantity. By default, Dim will deserialize this using <code>std::from_chars</code> if it is available, falling back to <code>std::strtold</code> and casting the result to the scalar type otherwise. You can override this behavior by specializing <code>dim:parse_scalar&lt;&gt;</code>. For serializing, stream output will use <code>operator&lt;&lt;</code>, <code>to_string</code> will use <code>std::to_string</code> while <code>std::formatter&lt;Q&gt;</code> will use <code>std::formatter&lt;scalar&gt;</code>.</p>
<p>The <code>[separator]</code> is optional. It consists of one character of either ' ', '*', or '_'. When Dim serializes a quantity, it uses '_' to match the way literals appear in code.</p>
<p>The <code>&lt;serialized unit&gt;</code> is more involved. When using a serializer that is locale-aware (<code>operator&lt;&lt;</code>, <code>std::format</code>, or <code>to_string</code>), the quantity facet's <code>output_symbol_map</code> will be used to determine the output symbol first. If the unit isn't in the map, serialization will fall back to be system's built-in method. For <code>format_quantity</code>, the <code>output_symbol_map</code> is an optional argument. If it isn't supplied or if the unit isn't in the map, it will likewise fall back to the built-in method. The built in method itself may have a specialized symbol for the unit. If so, that's used. Finally, if no other method has worked, the unit will be output using the base dimensions in the form </p><div class="fragment"><div class="line">dim0^exponent0dim1^exponent1...dim7^exponent7</div>
</div><!-- fragment --><p> If the exponent is zero, the associated dimension is not printed. The order of dimensions (different from the internal order) represents roughly observed practice:</p><ol type="1">
<li>Angle</li>
<li>Mass</li>
<li>Length</li>
<li>Temperature</li>
<li>Amount</li>
<li>Current</li>
<li>Luminosity</li>
<li>Time</li>
</ol>
<p>When deserializing a unit string, Dim first must determine which portion of the input is a unit string. This is done using the following state machine:</p>
<p><img src="symbol_scanner.svg" alt="Symbol scanner state machine" style="pointer-events: none;" class="inline"/></p>
<p>A select set of UTF-8 (Greek characters, the degree, degree Fahrenheit, degree Celsius, angstrom, kelvin, and ohm symbols) are also recognized as "alpha" class characters. Parentheses are accepted and are checked for balancing. When encountering other inputs, or when the state machine ends with an unterminated UTF-8 character or unbalanced parentheses, the state becomes <code>kError</code>. Once the string has been found, methods first consult the <code>input_symbol_map</code>. If the string is in the map, then that formatter is used for the conversion. If not, Dim falls back to using the system's parser.</p>
<h2><a class="anchor" id="autotoc_md32"></a>
Fallback Parser Symbols</h2>
<p>Non ASCII symbols in UTF-8 symbols are recognized, including mu, capital omega, the kelvin sign, and the ohm sign. In each of these cases, ASCII equivalents are also accepted as noted below.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Prefix   </th><th class="markdownTableHeadNone">Magnitude    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">y   </td><td class="markdownTableBodyNone">1e-24    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">z   </td><td class="markdownTableBodyNone">1e-21    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">a   </td><td class="markdownTableBodyNone">1e-18    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">f   </td><td class="markdownTableBodyNone">1e-15    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">p   </td><td class="markdownTableBodyNone">1e-12    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">n   </td><td class="markdownTableBodyNone">1e-9    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">μ*   </td><td class="markdownTableBodyNone">1e-6    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">m   </td><td class="markdownTableBodyNone">1e-3    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">c   </td><td class="markdownTableBodyNone">1e-2    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">d   </td><td class="markdownTableBodyNone">1e-1    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Y   </td><td class="markdownTableBodyNone">1e24    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Z   </td><td class="markdownTableBodyNone">1e21    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">E   </td><td class="markdownTableBodyNone">1e18    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">P   </td><td class="markdownTableBodyNone">1e15    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">T   </td><td class="markdownTableBodyNone">1e12    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">G   </td><td class="markdownTableBodyNone">1e9    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">M   </td><td class="markdownTableBodyNone">1e6    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">k   </td><td class="markdownTableBodyNone">1e3    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">h   </td><td class="markdownTableBodyNone">1e2   </td></tr>
</table>
<p>*"u" is also accepted</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Symbol   </th><th class="markdownTableHeadNone">Name    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">m   </td><td class="markdownTableBodyNone">meter    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">s   </td><td class="markdownTableBodyNone">second    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">rad   </td><td class="markdownTableBodyNone">radian    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">g   </td><td class="markdownTableBodyNone">gram    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">K*   </td><td class="markdownTableBodyNone">kelvin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">mol   </td><td class="markdownTableBodyNone">mole    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">A   </td><td class="markdownTableBodyNone">ampere    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">cd   </td><td class="markdownTableBodyNone">candela    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Hz   </td><td class="markdownTableBodyNone">hertz    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">sr   </td><td class="markdownTableBodyNone">steradian    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">N   </td><td class="markdownTableBodyNone">newton    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Pa   </td><td class="markdownTableBodyNone">pascal    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">J   </td><td class="markdownTableBodyNone">joule    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">W   </td><td class="markdownTableBodyNone">watt    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">C   </td><td class="markdownTableBodyNone">coulomb    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">V   </td><td class="markdownTableBodyNone">volt    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">F   </td><td class="markdownTableBodyNone">farad    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Ω**   </td><td class="markdownTableBodyNone">ohm    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">S   </td><td class="markdownTableBodyNone">siemens    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Wb   </td><td class="markdownTableBodyNone">weber    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">T   </td><td class="markdownTableBodyNone">tesla    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">H   </td><td class="markdownTableBodyNone">henry    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Im   </td><td class="markdownTableBodyNone">lumen    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Ix   </td><td class="markdownTableBodyNone">lux    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Bq   </td><td class="markdownTableBodyNone">becquerel    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Sv   </td><td class="markdownTableBodyNone">sievert    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">kat   </td><td class="markdownTableBodyNone">katal    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">L   </td><td class="markdownTableBodyNone">liter    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">eV   </td><td class="markdownTableBodyNone">electron volt    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">bar   </td><td class="markdownTableBodyNone">bar    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">&ndash;   </td><td class="markdownTableBodyNone">are***   </td></tr>
</table>
<p>*The kelvin sign (U+212A) is also accepted.</p>
<p>**"R" and the ohm sign (U+2126) are also accepted.</p>
<p>***The are (symbol "a") has been excluded as it makes parsing the units string ambiguous. (Is "Pa" a pascal or is it a petaare?) </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
