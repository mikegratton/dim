<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Dim: Dim: A Library for Compile-time Dimensional Analysis</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Dim
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Compile time dimensional analysis</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Dim: A Library for Compile-time Dimensional Analysis </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__home_mike_git_dim_README"></a></p><ul>
<li><a href="https://github.com/mikegratton/dim">GitHub Repository</a></li>
<li><a href="https://mikegratton.github.io/dim/">Documentation</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md1"></a>
Overview</h1>
<p>When working with dimension quantities like length and time in code, two major problems arise: </p><pre class="fragment">1. Different authors expect different units (feet instead of meters, say)
2. Function arguments are initialized wrong at the call site
</pre><p> For (2), I mean </p><div class="fragment"><div class="line">double compute_distance(double time_s, double speed_mps)</div>
<div class="line">{</div>
<div class="line">    return time_s*speed_mps;</div>
<div class="line">}</div>
<div class="line">// ...</div>
<div class="line"> </div>
<div class="line">double dist = compute_distance(speed, time); // Oops...</div>
</div><!-- fragment --><p> Dim solves these problems by using the C++ template feature to make each quantity a different type. This shifts the burden of dimension checking and many conversions to <em>compile time</em> rather than run time, making it very efficient. Dim is aimed at robotics and engineering applications, where calculations with dimensional quantities and especially quantities of <em>different dimensions</em> are common. Still, for scientific codes that rely on nondimensional values, it can still be helpful to read and write dimensional values at the start and end of the code.</p>
<p>In addition, one often must print a quantity to a string or parse a string into a quantity. Dim provides extensive IO support. The main path uses the iostream facet/locale system to stash your preferred formats and have them be applied wherever <code>operator&lt;&lt;</code> is used. However, for programs that do not wish to use iostreams, Dim provides a simple system based on c-strings for IO.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Quickstart</h1>
<p>Here's a basic annotated program </p><div class="fragment"><div class="line">#include &lt;cassert&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;dim/si.hpp&gt; // 1</div>
<div class="line">### Rationale</div>
<div class="line">using namespace si; // 2</div>
<div class="line">using namespace si::literal; // 3</div>
<div class="line"> </div>
<div class="line">Length compute_distance(Time t, Speed v) { return t*v; }</div>
<div class="line"> </div>
<div class="line">int main(int argc, char** argv)</div>
<div class="line">{</div>
<div class="line">    Time my_time = 3_s; // 4</div>
<div class="line">    Speed my_speed = 2.0 * foot/second; // 5</div>
<div class="line">    Length my_distance = compute_distance(my_time, my_speed);</div>
<div class="line">    std::cout &lt;&lt; &quot;In &quot; &lt;&lt; my_time &lt;&lt; &quot;, an object traveling at speed &quot; &lt;&lt; my_speed </div>
<div class="line">              &lt;&lt; &quot; travels &quot; &lt;&lt; my_distance &lt;&lt; &quot;\n&quot;; // 6</div>
<div class="line">    assert(sizeof(my_distance) == sizeof(double)); // No fluff.</div>
<div class="line">    return  0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Notes:</p>
<ol type="1">
<li>Use the SI system with stream operators</li>
<li>Not required, but move the si:: symbols into this namespace</li>
<li>To use literals (see 4), you need to have this <code>using</code> statement</li>
<li>Construct a Time quantity using a literal formatter. See <code><a class="el" href="literal_8hpp_source.html">dim/si/literal.hpp</a></code> for info on how to make your own.</li>
<li>Make a Speed quantity using arithmetic operators. <code>my_speed</code> is actually set to a value in m/s, but <em>it isn't necessary to know this</em> if you use Dim operators.</li>
<li>This prints "In 3_s, an object traveling at speed 0.6096_m_s^-1 travels 1.8288_m"</li>
</ol>
<p>You can find this code in <code>example/quickstart.cpp</code>.</p>
<p>In function <code>compute_distance</code>, the compiler has checked that e.g. Time*Speed results in units of Speed. If we instead tried to write a function body of </p><div class="fragment"><div class="line">Length compute_distance(Time t, Speed v) { return 0.5*t*t*v; }</div>
</div><!-- fragment --><p> the program would not compile. The error is </p><div class="fragment"><div class="line">../example/quickstart.cpp: In function ‘dim::si::Length compute_distance(dim::si::Time, dim::si::Speed)’:</div>
<div class="line">../example/quickstart.cpp:8:58: error: could not convert ‘dim::operator*&lt;dim::quantity&lt;dim::unit&lt;1, -1, 0, 0, 0, 0, 0, 0, dim::si::system&gt;, double&gt; &gt;(dim::operator*&lt;dim::quantity&lt;dim::unit&lt;0, 1, 0, 0, 0, 0, 0, 0, dim::si::system&gt;, double&gt; &gt;(dim::operator*(5.0e-1, t), t), v)’ from ‘quantity&lt;unit&lt;[...],1,[...],[...],[...],[...],[...],[...],[...]&gt;,[...]&gt;’ to ‘quantity&lt;unit&lt;[...],0,[...],[...],[...],[...],[...],[...],[...]&gt;,[...]&gt;’</div>
<div class="line">    8 | Length compute_distance(Time t, Speed v) { return 0.5*t*t*v; }</div>
</div><!-- fragment --><p> More on what all this template business is is below, but suffice to say that Length does not match the dimensions of Speed * Time * Time.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Building Dim</h1>
<p>Dim is written in C++11 and has no dependencies. If C++14 or higher is available, a few extra <code>constexpr</code> features are enabled.</p>
<p>The easiest way to use Dim is to put the code in a subdirectory of your project and add </p><div class="fragment"><div class="line">add_subdirectory(dim)</div>
</div><!-- fragment --><p> to your <code>CMakelists.txt</code> file. This will give you a target <code>dim</code> that you can depend on. There isn't much to compile in Dim, so the additional build time should be small.</p>
<p>Alternatively, you can run the install target to install Dim per usual.</p>
<h1><a class="anchor" id="autotoc_md4"></a>
Design</h1>
<h2><a class="anchor" id="autotoc_md5"></a>
Understanding Dimensional Analysis</h2>
<p>In the standard low-energy physics model, there are seven dimensions to the unit:</p>
<ol type="1">
<li>Length</li>
<li>Time</li>
<li>Mass</li>
<li>Amount of substance</li>
<li>Luminous intensity</li>
<li>Temperature</li>
<li>Electrical current</li>
</ol>
<p>Note this library adds an eigth dimension of angle, discussed below. For each of these eight dimensions, a quantity may have an integer multiplier. For example, acceleration has dimensions of L/T^2 or one length, minus two time dimensions.</p>
<p>Dimensional analysis is best understood in analogy to vectors. Just as a vector can be broken down into a magnitude and a direction, a dimensional quantity is the product of a nondimensional scalar and a dimensional unit. The name is suggestive, and it should be: the direction for a vector is itself a vector with unit magnitude. The "direction" of a dimensional quantity is itself a dimensional quantity with a unit scalar &ndash; i.e., a "unit" dimension. Dimensional quantities obey a simple algebra: q1 and q2 can be summed if their units match. The product q1*q2 is s1 * s2 * (u1+u2), where qi has scalar si and unit ui. Here, unit addition obeys vector rules.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Types and Templates</h2>
<p>Dim fundamentally works with a class template of <code>quantity</code>. This in turn depends on three parameters:</p>
<ol type="1">
<li>The scalar type (double for the SI system)</li>
<li>The unit</li>
<li>The system (e.g. SI)</li>
</ol>
<p>The system is effectively a tag type to prevent quantities from different systems from being mixed. Dim only ships with the SI system, so this only matters if you are building your own system.</p>
<p>The unit is the core of Dim. It is a set of eight short int template parameters representing the seven fundamental dimension of the standard model plus an angle dimension (see below). These are template parameters, not class members. All operations on the unit are performed at compile time, and a quantity has a size exactly equal to its scalar type. The unit type is actually a separate template class that acts like a quantity with scalar value of one, though Dim goes to some length to hide the unit type from you. For the SI system, the fundamental dimensions have unit types defined as <code>meter_</code>, <code>second_</code>, <code>radian_</code>, and so on, while the quantities do not have the trailing underscore.</p>
<h3><a class="anchor" id="autotoc_md7"></a>
Defining Custom Quantities</h3>
<p>You can define new quantities simply by using the C++ decltype operator. For example, suppose we wanted to represent a screw pitch. We could do </p><div class="fragment"><div class="line">using Pitch = decltype(meter/radian);</div>
</div><!-- fragment --><p> and then Pitch becomes a convenient alias. See the code <code>example/advanced.cpp</code>.</p>
<h3><a class="anchor" id="autotoc_md8"></a>
Defining Custom Literal Formatters</h3>
<p>Dim ships with literal formatters based on the NIST standard. But often other formatters are useful for your domain. Suppose we want angular degrees to have the format <code>_deg</code>. We can define </p><div class="fragment"><div class="line">inline constexpr Angle operator &quot;&quot; _deg(long double x) { return static_cast&lt;double&gt;(x)*degree; } \</div>
<div class="line">inline constexpr Angle operator &quot;&quot; _deg(unsigned long long x) { return static_cast&lt;double&gt;(x)*degree; } </div>
</div><!-- fragment --><p> so that <code>1_deg</code> and <code>1.2_deg</code> are both recognized as Angle constexprs. See the code <code>example/advanced.cpp</code>.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
NIST SP 811 Standard and the Angle Unit</h2>
<p><a href="https://www.nist.gov/pml/special-publication-811">The National Institute of Standards and Technology Special Publication 881</a> is the most complete guide to SI units. Wherever possible, Dim uses the NIST SP 881 unit names, abbreviations, and so on. Note that in this standard, plurals are generally avoided, so it is "meter" and not "meters."</p>
<p>There is one major exception: Dim considers Angle to be a fundamental dimension. This choice resolves a lot of ambiguities in the standard system. For instance, the bedevilment caused by wondering if a frequency is Hz or is a <em>rotational frequency</em> is resolved. These have different units: Hz is 1/s while rotational frequency is rad/s. Other notable changes are that the units of torque ang luminous flox. The units of torque are N m / rad, so that if you apply this torque through a full revolution, you see the work done is (N m / rad) * (2 * pi * rad) = 2 * pi * W. Likewise the lumen now has base units of candela * steradian = candela * radian^2.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Type Definitions Attached to Quantity</h2>
<p>Every quantity class holds the typedefs</p>
<ul>
<li><code>scalar</code> &ndash; the scalar type, e.g. double</li>
<li><code>unit</code> &ndash; the underlying unit array (it is a type all of whose instances are the same)</li>
<li><code>type</code> &ndash; the type of this quantity</li>
<li><code>dimensionless</code> &ndash; the unit in this system that is all zero</li>
</ul>
<h2><a class="anchor" id="autotoc_md11"></a>
The &lt;tt&gt;dimensionless_cast&lt;/tt&gt; Escape Hatch</h2>
<p>Dim allows you to "escape" from the confines of the library at will. The magnitude of a quantity is available via <code>dimensionless_cast()</code>. Accessing the magnitude in this way means potentially having dimensional mismatch (that is, the library cannot check you), but this is very useful when serializing or deserializing data.</p>
<h1><a class="anchor" id="autotoc_md12"></a>
Guard Values, NaN, and &lt;tt&gt;bad_quantity&lt;/tt&gt;</h1>
<p>Dim uses NaN as a guard value in several places. You can construct a "bad" version of a type via </p><div class="fragment"><div class="line">Length its_bad = Length::bad_quantity();</div>
</div><!-- fragment --><p> and you can check for badness with <code>is_bad()</code>. See <a href="#Bad-Quantities-and-NaN">Bad Quantities and NaN</a> for details.</p>
<h2><a class="anchor" id="autotoc_md13"></a>
Math with Quantities</h2>
<p>Quantities overload the arithemetic operators "+", "-", "*", "/", the assignment operators "=", "+=", "-=", "*=", "/=", and the full set of comparison operators. In short, they behave just like doubles except for the restrictions regarding dimensions. In addition, the following overoads are defined:</p>
<ul>
<li><code>abs()</code>: Computes the absolute value.</li>
<li><code>sqrt()</code>: Computes the square root <em>provided</em> all of the dimensions are divisible by two.</li>
<li><code>pow&lt;n&gt;()</code> : Computes the nth power where n is an integer.</li>
<li><code>ratpow&lt;p,q&gt;()</code> Computes the quantity to the p/q power, provided all of the resulting dimensions are integers.</li>
</ul>
<p>In addition, Angle types have the related trigonometric functions defined:</p>
<ul>
<li><code>double sin(Angle const&amp; q)</code></li>
<li><code>double cos(Angle const&amp; q)</code></li>
<li><code>double tan(Angle const&amp; q)</code></li>
<li><code>Angle asin(double const&amp; x)</code></li>
<li><code>Angle acos(double const&amp; x)</code></li>
<li><code>Angle atan(double const&amp; x)</code></li>
<li><code>Angle atan2(double const&amp; x, double const&amp; y)</code></li>
<li><code>template&lt;class Q&gt; Angle atan2(Q const&amp; x, Q const&amp; y)</code></li>
</ul>
<p>Note the actual definition of the last is slightly different so that it is only available if Q is a quantity.</p>
<h2><a class="anchor" id="autotoc_md14"></a>
Understanding Errors</h2>
<p>Dim uses static assertions to improve most compile errors. As Dim is a template library, there's a lot of "angry template error" messages to wade through, but you should be able to find a more helpful error in the spew, such as </p><div class="fragment"><div class="line">... error: static assertion failed: Length dimensions do not match.</div>
</div><!-- fragment --><p>In some cases, the compiler will give errors of the form </p><div class="fragment"><div class="line">... error: conversion from ‘quantity&lt;unit&lt;1,[...],[...],[...],[...],[...],[...],[...],[...]&gt;,[...]&gt;’ to non-scalar type ‘quantity&lt;unit&lt;2,[...],[...],[...],[...],[...],[...],[...],[...]&gt;,[...]&gt;’ requested</div>
<div class="line">    8 |     si::Area A2 = L;</div>
</div><!-- fragment --><p> To decode this, we've tried to assign a length to an area. You can see in the template that the RHS has a length dimension of 1 while the LHS has a length dimension of 2.</p>
<h1><a class="anchor" id="autotoc_md15"></a>
Input and Output</h1>
<h2><a class="anchor" id="autotoc_md16"></a>
Formatters, Facets, and Locales</h2>
<p>The formatter is a simple class that associates a string symbol with information on how to nondimensionalize a quantity. For example </p><div class="fragment"><div class="line">si::formatter&lt;si::Angle&gt; degree_formatter(&quot;deg&quot;, si::degree);</div>
</div><!-- fragment --><p> will format angles as degrees. The template parameter is the quantity type (<code>si::Angle</code>), the first argument is the symbol string (<code>deg</code>), and the second argument gives what you would multiply 1.0 by to obtain a quantity of the indicated symbol (<code>si::degree</code>). There's an optional third argument that is used for temperature conversion as an additive offset: </p><div class="fragment"><div class="line">si::formatter&lt;si::Temperature&gt; fahrenheit_format(&quot;F&quot;, 5./9.*kelvin, 255.37*kelvin);</div>
</div><!-- fragment --><p> Hey, no one ever said thermodynamics was easy. <br  />
</p>
<p>Formatters can be used directly, providing <code>input</code> and <code>output</code> methods. Input takes the form </p><div class="fragment"><div class="line">si::Angle x = degree_formatter.input(90.0);</div>
</div><!-- fragment --><p> while output is </p><div class="fragment"><div class="line">si::formatted_quantity&lt;double&gt; fmt = degree_formatter.output(2_rad);</div>
</div><!-- fragment --><p> which divides the output into a scalar (double) part <code>value()</code> and a <code>char const*</code> symbol part <code>symbol()</code>. This allows you to do </p><div class="fragment"><div class="line">printf(&quot;My angle is %g_%s\n&quot;, fmt.value(), fmt.symbol());</div>
</div><!-- fragment --><p> or put the result into structured XML, etc. If you are using streams, you can just do </p><div class="fragment"><div class="line">std::cout &lt;&lt; &quot;My angle is &quot; &lt;&lt; degree_formatter.output(2_rad) &lt;&lt; &quot;\n&quot;;</div>
</div><!-- fragment --><p>Dim taps into the facet/locale system of std::iostream to make these formatters available transparently to streaming operators. The facet allows <code>operator&lt;&lt;</code> and <code>operator&gt;&gt;</code> to look up the appropriate formatter for the quantity and apply it. To use this system, you need to install it into the global locale. You probably want to adjust the format to your tastes. <br  />
 Here's an example of setting up angles to be output in degrees by default: </p><div class="fragment"><div class="line">#include &lt;dim/si.hpp&gt;</div>
<div class="line">namespace si = ::dim::si;</div>
<div class="line"> </div>
<div class="line">int main(int argc, char** argv)</div>
<div class="line">{</div>
<div class="line">    // Let&#39;s format angles as degrees</div>
<div class="line">    auto* facet = si::system::make_default_facet(); // obtain the default si facet    </div>
<div class="line">    si::formatter&lt;si::Angle&gt; degree_formatter(&quot;deg&quot;, si::degree);</div>
<div class="line">    facet-&gt;output_formatter(degree_formatter); // Set a new output format for angles    </div>
<div class="line">    si::add_to_global_locale(facet); // Install the updated facet in the global locale</div>
<div class="line">    </div>
<div class="line">    si::Angle angle = M_PI*0.5 * si::radian;    </div>
<div class="line">    std::cout &lt;&lt; &quot;Angle is &quot; &lt;&lt; angle &lt;&lt; &quot;\n&quot;;</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>What happens if the facet doesn't exist in the locale, or if the facet doesn't have a formatter for our case? Dim provides fallback options in these cases described below.</p>
<h2><a class="anchor" id="autotoc_md17"></a>
Printing Quantities</h2>
<p>Printing takes advantage of the fact that each quantity can only have one default way to print it. Thus the facet maintains a map indexed by the quantity's dimension to the formatter to use. When you call <code>facet-&gt;output_formatter()</code>, you are replacing the default format. If you want to override the format only in certain places, you can construct and use the formatter as shown above.</p>
<h3><a class="anchor" id="autotoc_md18"></a>
Basic Format</h3>
<p>But what if there's no format? Well, Dim has a basic fallback output format. A symbol is associated with each dimension so a unit symbol can be reconstructed. This is correct, but it isn't pretty. Thus suppose we had a torque we wanted to print: </p><div class="fragment"><div class="line">si::Torque T = 3_N * 2_m / 1.2_rad;</div>
<div class="line">std::cout &lt;&lt; &quot;Torque is &quot; &lt;&lt; T &lt;&lt; &quot;\n&quot;;</div>
</div><!-- fragment --><p> If there's nothing in the facet about <code>si::Torque</code>, the output will be "5_rad^-1_kg_m^2_s^-2".</p>
<h2><a class="anchor" id="autotoc_md19"></a>
Parsing Quantities</h2>
<p>Input is a different beast. One interesting part is that because Dim is strongly typed, we know the desired destination quantity type. Really we need to see that the string can be parsed to a matching dimension. For example, </p><div class="fragment"><div class="line">si::Angle the_angle;</div>
<div class="line">std::cout &lt;&lt; &quot;Enter an angle: &quot;;</div>
<div class="line">std::cin &gt;&gt; the_angle;</div>
</div><!-- fragment --><p> If the user enters is <code>3 rad</code>, all is well. If the enters <code>12 ft</code>, we've got a problem. Dim doesn't use exceptions. Instead <code>the_angle</code> will be set to a "bad" quantity &ndash; a silent <code>NaN</code>. The test <code>the_angle.is_bad()</code> can check that a valid input was recieved.</p>
<h3><a class="anchor" id="autotoc_md20"></a>
Stream-based Parsing</h3>
<p>What formatters are available for what types? Well, the facet maintains a map of maps for input. First, since we know the destination quantity type, it looks up the map for that type. The resulting map is then indexed by the symbol string. If an exact string match is found, that formatter is used to parse the quantity. This provides a flexible system where you can provide formatters for whatever domain-specific conventions you work with. For instance, here's the default map that Dim ships with for lengths: </p><div class="fragment"><div class="line">static const format_map&lt;Length&gt; s_known {</div>
<div class="line">    {&quot;in&quot;,   formatter&lt;Length&gt;(&quot;in&quot;, inch) },</div>
<div class="line">    {&quot;inch&quot;, formatter&lt;Length&gt;(&quot;inch&quot;, inch)},</div>
<div class="line">    {&quot;ft&quot;,   formatter&lt;Length&gt;(&quot;ft&quot;, foot)},</div>
<div class="line">    {&quot;foot&quot;, formatter&lt;Length&gt;(&quot;foot&quot;, foot)},</div>
<div class="line">    {&quot;yd&quot;,   formatter&lt;Length&gt;(&quot;yd&quot;, yard)},</div>
<div class="line">    {&quot;yard&quot;, formatter&lt;Length&gt;(&quot;yard&quot;, yard)},</div>
<div class="line">    {&quot;mi&quot;,   formatter&lt;Length&gt;(&quot;mi&quot;, mile)},</div>
<div class="line">    {&quot;mile&quot;, formatter&lt;Length&gt;(&quot;mile&quot;, mile)},</div>
<div class="line">    {&quot;nmi&quot;,  formatter&lt;Length&gt;(&quot;nmi&quot;, nautical_mile)},</div>
<div class="line">    {&quot;nautical_mile&quot;, formatter&lt;Length&gt;(&quot;nautical_mile&quot;, nautical_mile)}</div>
<div class="line">};</div>
</div><!-- fragment --><p> Notice that <code>m</code> and <code>cm</code> and so on aren't there because they are handled by the fallback parser below. (SI units are generally easy to parse). Instead, here are conventions suggested by NIST SP 811. But suppose for your domain, you wanted to accept "feet" for "foot" and "nm" for nautical mile (yikes, symbol clash with nanometer &ndash; but you know what your users expect). You could add these to the facet via </p><div class="fragment"><div class="line">auto* facet = si::system::make_default_facet(); // obtain the default si facet    </div>
<div class="line">facet-&gt;input_formatter(formatter&lt;Length&gt;(&quot;feet&quot;, foot));</div>
<div class="line">facet-&gt;input_formatter(formatter&lt;Length&gt;(&quot;nm&quot;, nautical_mile));</div>
</div><!-- fragment --><p> Because the map is consulted first, you've overridden the meaning of "nm" for your program.</p>
<h3><a class="anchor" id="autotoc_md21"></a>
Fallback Parser</h3>
<p>When a symbol isn't recognized, Dim falls back to a Flex/Bison built parser for SI types. This parser understands the SI prefixes and symbols defined in NIST SP 811. The parser recognizes <code>_</code>, <code>*</code> and space as multiplication, <code>/</code> as division, and <code>^</code> as exponentiation, as well as parentheses.</p>
<p>The symbol tables differ slightly from the standard:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Prefix   </th><th class="markdownTableHeadNone">Magnitude    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">y   </td><td class="markdownTableBodyNone">1e-24    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">z   </td><td class="markdownTableBodyNone">1e-21    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">a   </td><td class="markdownTableBodyNone">1e-18    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">f   </td><td class="markdownTableBodyNone">1e-15    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">p   </td><td class="markdownTableBodyNone">1e-12    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">n   </td><td class="markdownTableBodyNone">1e-9    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">u*   </td><td class="markdownTableBodyNone">1e-6    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">m   </td><td class="markdownTableBodyNone">1e-3    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">c   </td><td class="markdownTableBodyNone">1e-2    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">d   </td><td class="markdownTableBodyNone">1e-1    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Y   </td><td class="markdownTableBodyNone">1e24    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Z   </td><td class="markdownTableBodyNone">1e21    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">E   </td><td class="markdownTableBodyNone">1e18    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">P   </td><td class="markdownTableBodyNone">1e15    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">T   </td><td class="markdownTableBodyNone">1e12    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">G   </td><td class="markdownTableBodyNone">1e9    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">M   </td><td class="markdownTableBodyNone">1e6    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">k   </td><td class="markdownTableBodyNone">1e3    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">h   </td><td class="markdownTableBodyNone">1e2   </td></tr>
</table>
<p>where mu (&amp;#956;) has been replaced by "u". The unit symbols are</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Symbol   </th><th class="markdownTableHeadNone">Name    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">m   </td><td class="markdownTableBodyNone">meter    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">s   </td><td class="markdownTableBodyNone">second    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">rad   </td><td class="markdownTableBodyNone">radian    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">g   </td><td class="markdownTableBodyNone">gram    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">K   </td><td class="markdownTableBodyNone">kelvin    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">mol   </td><td class="markdownTableBodyNone">mole    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">A   </td><td class="markdownTableBodyNone">ampere    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">cd   </td><td class="markdownTableBodyNone">candela    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Hz   </td><td class="markdownTableBodyNone">hertz    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">sr   </td><td class="markdownTableBodyNone">steradian    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">N   </td><td class="markdownTableBodyNone">newton    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Pa   </td><td class="markdownTableBodyNone">pascale    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">J   </td><td class="markdownTableBodyNone">joule    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">W   </td><td class="markdownTableBodyNone">watt    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">C   </td><td class="markdownTableBodyNone">coulomb    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">V   </td><td class="markdownTableBodyNone">volt    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">F   </td><td class="markdownTableBodyNone">farad    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">R*   </td><td class="markdownTableBodyNone">ohm    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">S   </td><td class="markdownTableBodyNone">siemens    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Wb   </td><td class="markdownTableBodyNone">weber    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">T   </td><td class="markdownTableBodyNone">tesla    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">H   </td><td class="markdownTableBodyNone">henry    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Im   </td><td class="markdownTableBodyNone">lumen    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Ix   </td><td class="markdownTableBodyNone">lux    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Bq   </td><td class="markdownTableBodyNone">becquerel    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Sv   </td><td class="markdownTableBodyNone">sievert    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">kat   </td><td class="markdownTableBodyNone">katal    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">L   </td><td class="markdownTableBodyNone">liter    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">eV   </td><td class="markdownTableBodyNone">electron volt    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">a   </td><td class="markdownTableBodyNone">acre    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">bar   </td><td class="markdownTableBodyNone">bar   </td></tr>
</table>
<p>where Omega (&amp;#937;) has been replaced by "R".</p>
<h1><a class="anchor" id="autotoc_md22"></a>
Advanced Topics</h1>
<h2><a class="anchor" id="autotoc_md23"></a>
Metaprograming with Quantities</h2>
<p>One pitfall for C++ class templates is that each instantiation is a totally separate class at run time from every other one. Thus <code>si::Length</code> and <code>si::Time</code> are no more related than <code>std::string</code> and <code>double</code>. This is often painful for code that wants to handle these types in a uniform way. To aid with this, Dim provides a macro <code>DIM_IS_QUANTITY</code> that works with the C++ Substitution Failure is not an Error (SFINAE &ndash; this language has the <em>worst</em> jargon). It works like this </p><div class="fragment"><div class="line">template&lt;class Q, DIM_IS_QUANTITY(Q)&gt;</div>
<div class="line">char* print_quantity(char* o_quant_str, Q const&amp; q)</div>
<div class="line">{</div>
<div class="line">    int offset = sprintf(o_quant_str, &quot;%g_&quot;, static_cast&lt;double&gt;(q.value));</div>
<div class="line">    print_unit(o_quant_str+offset, q);</div>
<div class="line">    return o_quant_str;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The print_quantity function template is thus only defined for quantity types, where we know <code>q</code> will have a member <code>value</code>.</p>
<h2><a class="anchor" id="autotoc_md24"></a>
Micro-Optimization for Nondimensionalization</h2>
<p>If you need to nondimensionalize a quantity say for serialization, you may want to squeeze out all the performance you can while still using the facilities of Dim to catch errors. For example, here are three ways to nondimensionalize a length: </p><div class="fragment"><div class="line">Length L = 2_m;</div>
<div class="line">double v1 = L.value; // 1</div>
<div class="line">double v1 = L / meter; // 2</div>
<div class="line">double v2 = L / meter_; // 3</div>
</div><!-- fragment --><p> (1) just uses our knowledge that lengths are stored in meters. It is a bit unsafe, however. (2) does just what it says, provide the length of L in meters. However, since <code>meter</code> is itself a Length quantity, this actually performs a floating point division (2.0/1.0). (3) uses the specially defined <em>unit</em> types (these are the same as the quantities but have a trailing underscore). The <code>operator/</code> action here understands that a unit has, well, <em>unit</em> value, so avoids the division. In fact, at runtime, (1) and (3) produce the same assembly code.</p>
<h2><a class="anchor" id="autotoc_md25"></a>
Fractional Dimensions</h2>
<p>Dim does not support fractional dimension like "m^1/2" that are used in some domains. Supporting these really complicates the metaprogramming and makes your program compile slower. You can typically work with e.g. squared quantities to obtain integer dimensions. (For fractal dimensions, why are you using this library at all?) If this is too much of a burden, the <a href="https://www.boost.org/doc/libs/1_80_0/doc/html/boost_units.html">boost::units</a> library provides this feature.</p>
<h2><a class="anchor" id="autotoc_md26"></a>
Bad Quantities and NaN</h2>
<p>When <code>__FAST_MATH__</code> is defined, Dim uses an expanded notion of a "bad" floating point number that includes numbers that are Inf, -Inf, and NaN in IEEE 754 floating point. The rationale is that on embedded systems (ARM in particular), you need to compile <code>-Ofast</code> to obtain access to SIMD instructions. When you do this, <code>std::isnan()</code> always evaluates to false. Dim uses its own <code>is_bad</code> function to work around this. The trade-off is that algorithms relying on correct behavior with Inf will see values as "bad". But such algorithms are usually limited to specialized scientific codes rather than the more general robotics and engineering codes Dim is intended for.</p>
<p>Note if <code>__FAST_MATH__</code> isn't defined, then is_bad() is just checking if the value is NaN.</p>
<h1><a class="anchor" id="autotoc_md27"></a>
Appendix A: Default Quantity Input Symbols</h1>
<p>For non-SI quantities, Dim provides a default override map for typical unit abbreviations. See <a href="#Stream-based-Parsing">Stream-based Parsing</a> for information on changing these lists. Note that standard SI notation doesn't appear below as the parser handles it just fine.</p>
<h2><a class="anchor" id="autotoc_md28"></a>
Temperature</h2>
<ul>
<li>"F" : Fahrenheit</li>
<li>"R" : Rankine</li>
<li>"C" : Celsius</li>
</ul>
<h2><a class="anchor" id="autotoc_md29"></a>
Length</h2>
<ul>
<li>"in" : Inch</li>
<li>"inch" : Inch</li>
<li>"ft" : Foor</li>
<li>"foot" : Foot</li>
<li>"yd" : Yard</li>
<li>"yard" : Yard</li>
<li>"mi" : Mile</li>
<li>"mile" : Mile</li>
<li>"nmi" : Nautical Mile</li>
<li>"nautical_mile" : Nautical Mile</li>
</ul>
<h2><a class="anchor" id="autotoc_md30"></a>
Time</h2>
<ul>
<li>"min" : Minute</li>
<li>"h" : Hour</li>
<li>"hr" : Hour</li>
<li>"minute" : Minute</li>
<li>"hour" : Hour</li>
</ul>
<h2><a class="anchor" id="autotoc_md31"></a>
Mass</h2>
<ul>
<li>"oz" : Ounce (mass)</li>
<li>"lb" : Pound (mass)</li>
<li>"lbm" : Pound (mass)</li>
<li>"slug" : Slug</li>
<li>"ounce" : Ounce (mass)</li>
<li>"pound" : Pound (mass)</li>
<li>"pound_mass" : Pound (mass)</li>
</ul>
<h2><a class="anchor" id="autotoc_md32"></a>
Angle</h2>
<ul>
<li>"radian" : Radian</li>
<li>"deg" : Degree</li>
<li>"mil" : Mil</li>
<li>"mrad" : Milliradian</li>
<li>"milliradian" : Milliradian</li>
<li>"turn" : Turn</li>
<li>"'" : Minute (angle)</li>
<li>"min" : Minute (angle)</li>
<li>"minute" : Minute (angle)</li>
<li>"\"" : Second (angle)
* "s" : Second (angle)
* "second" : Second (angle)</li>
</ul>
<h2><a class="anchor" id="autotoc_md33"></a>
SolidAngle</h2>
<ul>
<li>"steradian" : Steradian</li>
<li>"sp" : Spat</li>
<li>"spat" : Spat</li>
</ul>
<h2><a class="anchor" id="autotoc_md34"></a>
Force</h2>
<ul>
<li>"dyn" : Dyne</li>
<li>"lb" : Pound (force)</li>
<li>"lbf" : Pound (force)</li>
<li>"pound" : Pound (force)</li>
<li>"pound_force" : Pound (force)</li>
</ul>
<h2><a class="anchor" id="autotoc_md35"></a>
Pressure</h2>
<ul>
<li>"lbf/in^2" : Pound (force) per Square Inch</li>
<li>"lbf_in^-2" : Pound (force) per Square Inch</li>
<li>"lb/in^2" : Pound (force) per Square Inch</li>
<li>"lb_in^-2" : Pound (force) per Square Inch</li>
<li>"pounds_per_inch2" : Pound (force) per Square Inch</li>
<li>"pounds_per_square_inch" : Pound (force) per Square Inch</li>
<li>"torr" : Torr</li>
<li>"atm" : Standard Atmosphere</li>
<li>"atmosphere" : Standard Atmosphere</li>
</ul>
<h2><a class="anchor" id="autotoc_md36"></a>
Energy</h2>
<ul>
<li>"kW_hr" : Kilowatt Hour</li>
<li>"kW*hr" : Kilowatt Hour</li>
<li>"kWhr" : Kilowatt Hour</li>
<li>"erg" : Erg</li>
<li>"foot_pound" : Foot Pound (force)</li>
<li>"ft_lb" : Foot Pound (force)</li>
<li>"ft_lbf" : Foot Pound (force)</li>
<li>"BTU" : British Thermal Unit</li>
</ul>
<h2><a class="anchor" id="autotoc_md37"></a>
Power</h2>
<ul>
<li>"hp" : Horsepower</li>
</ul>
<h2><a class="anchor" id="autotoc_md38"></a>
Area</h2>
<ul>
<li>"acre" : Acre</li>
<li>"sq_mi" : Square Mile</li>
<li>"mi^2" : Square Mile</li>
<li>"mile2" : Square Mile</li>
<li>"sq_ft" : Square Foot</li>
<li>"ft^2" : Square Foot</li>
<li>"foot2" : Square Foot</li>
</ul>
<h2><a class="anchor" id="autotoc_md39"></a>
Volume</h2>
<ul>
<li>"cc" : Cubic Centimeter</li>
<li>"gal" : Gallon</li>
<li>"gallon" : Gallon</li>
<li>"acre_ft" : Acre Foot</li>
<li>"acre_foot" : Acre Foot</li>
<li>"cu_ft" : Cubic Foot</li>
<li>"ft^3" : Cubic Foot</li>
<li>"cubic_foot" : Cubic Foot</li>
<li>"cu_in" : Cubic Inch</li>
<li>"in^3" : Cubic Inch</li>
<li>"cubic_inch" : Cubic Inch</li>
<li>"cu_yd" : Cubic Inch</li>
<li>"yd^3" : Cubic Inch</li>
<li>"cubic_yard" : Cubic Inch</li>
</ul>
<h2><a class="anchor" id="autotoc_md40"></a>
FlowRate</h2>
<ul>
<li>"gal/s" : Gallon per Second</li>
<li>"gal/min" : Gallon per Minute</li>
<li>"meter3/second" : Cubic Meter per Second</li>
<li>"liter/second" : Liter per Second</li>
<li>"gallon/second" : Gallon per Second</li>
<li>"gallon/minute" : Gallon per Minute</li>
</ul>
<h2><a class="anchor" id="autotoc_md41"></a>
Speed</h2>
<ul>
<li>"mps" : Meter per Second</li>
<li>"kph" : Kilometer per Hour</li>
<li>"mph" : Mile per Hour</li>
<li>"miles_per_hour" : Mile per Hour</li>
<li>"knot" : Knot</li>
<li>"kn" : Knot</li>
<li>"kt" : Knot</li>
<li>"ft/s" : Foot per Second</li>
<li>"feet_per_second" : Foot per Second</li>
</ul>
<h2><a class="anchor" id="autotoc_md42"></a>
Acceleration</h2>
<ul>
<li>"ft/s^2" : Foot per Squared Second</li>
<li>"feet_per_second2" : Foot per Squared Second</li>
</ul>
<h2><a class="anchor" id="autotoc_md43"></a>
AngularRate</h2>
<ul>
<li>"deg/s" : Degree per Second</li>
<li>"degrees_per_second" : Degree per Second</li>
<li>"radians_per_second" : Radian per Second</li>
</ul>
<h2><a class="anchor" id="autotoc_md44"></a>
AngularAcceleration</h2>
<ul>
<li>"deg/s^2" : Degree per Squared Second</li>
<li>"degrees_per_second2" : Degree per Squared Second</li>
<li>"radians_per_second2" : Radian per Squared Second </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
